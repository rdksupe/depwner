import sqlite3
import pandas as pd
import json
from pathlib import Path
from datetime import datetime
import calendar
import matplotlib.pyplot as plt
import seaborn as sns

def convert_to_serializable(obj):
    """Convert pandas and numpy types to native Python types"""
    if isinstance(obj, (pd.Timestamp, pd.Period)):
        return obj.strftime('%Y-%m-%d')
    elif isinstance(obj, pd.Series):
        return obj.to_dict()
    elif isinstance(obj, pd.DataFrame):
        return obj.to_dict(orient='records')
    elif isinstance(obj, dict):
        return {str(k): convert_to_serializable(v) for k, v in obj.items()}
    elif isinstance(obj, (list, tuple)):
        return [convert_to_serializable(i) for i in obj]
    return obj

def json_serial(obj):
    """JSON serializer for objects not serializable by default json code"""
    return convert_to_serializable(obj)

class MalwareAnalyzer:
    def __init__(self, db_path):
        self.conn = sqlite3.connect(db_path)
        # Filter out N/A and empty values in the SQL query itself
        self.df = pd.read_sql_query("""
            SELECT md5_hash, first_seen_utc, signature 
            FROM malware_hashes 
            WHERE first_seen_utc IS NOT NULL 
            AND signature IS NOT NULL 
            AND signature != 'N/A'
            AND signature != ''
            AND signature != 'unknown'
            AND signature != 'Unknown'
        """, self.conn)
        
        self.df['first_seen_utc'] = pd.to_datetime(self.df['first_seen_utc'])
        self.df['signature'] = self.df['signature'].astype(str)
        
        # Setup directories
        self.output_dir = Path('visualization_data')
        self.img_dir = self.output_dir / 'images'
        self.output_dir.mkdir(exist_ok=True)
        self.img_dir.mkdir(exist_ok=True)
        
        # Configure plotting defaults with updated style
        sns.set_theme(style="whitegrid")
        plt.rcParams.update({
            'figure.figsize': [12, 8],
            'figure.dpi': 300,
            'svg.fonttype': 'none',
            'axes.grid': True,
            'grid.linestyle': '--',
            'grid.alpha': 0.6,
            'font.size': 10,
            'axes.labelsize': 12,
            'axes.titlesize': 14,
            'xtick.labelsize': 10,
            'ytick.labelsize': 10,
            'legend.fontsize': 10,
            'figure.titlesize': 16
        })

    def save_plot(self, filename):
        """Save plots in both SVG and PNG formats"""
        plt.tight_layout()
        # Save as SVG
        plt.savefig(self.img_dir / f"{filename}.svg", format='svg', bbox_inches='tight')
        # Save as PNG for preview
        plt.savefig(self.img_dir / f"{filename}.png", dpi=300, bbox_inches='tight')
        plt.close()

    def export_data(self):
        """Export all visualization data and save plots"""
        required_visualizations = {}
        
        # Process each visualization with error handling
        visualization_methods = {
            'hourly_activity': self.get_hourly_activity,
            'malware_trends': self.get_trend_data,
            'new_families_timeline': self.get_new_families_timeline,
            'seasonal_heatmap': self.get_monthly_activity,
            'signature_distribution': self.get_signature_stats,
            'signature_evolution': self.get_signature_evolution,
            'temporal_heatmap': self.get_temporal_patterns,
            'summary_stats': self.get_summary_stats
        }
        
        for name, method in visualization_methods.items():
            try:
                required_visualizations[name] = method()
                print(f"Generated {name}")
            except Exception as e:
                print(f"Warning: Failed to generate {name}: {str(e)}")
                required_visualizations[name] = {'error': str(e)}

        # Save data files
        for name, data in required_visualizations.items():
            try:
                output_file = self.output_dir / f"{name}.json"
                with open(output_file, 'w') as f:
                    json.dump(data, f, default=str, indent=2)
            except Exception as e:
                print(f"Warning: Failed to save {name} data: {str(e)}")

        print(f"Exported data to {self.output_dir}/")
        print(f"Saved visualizations to {self.img_dir}/")
        return required_visualizations

    def get_new_families_timeline(self):
        """Track first appearances of malware families"""
        # Convert first_seen to datetime index
        first_seen = (self.df.groupby('signature')['first_seen_utc']
                     .min()
                     .sort_values()
                     .to_frame())
        first_seen.index = pd.to_datetime(first_seen['first_seen_utc'])
        
        # Resample by month
        monthly_new = first_seen.resample('ME')['first_seen_utc'].count()
        
        # Format data in Plotly format
        data = {
            'data': [{
                'type': 'bar',
                'x': monthly_new.index.strftime('%Y-%m').tolist(),
                'y': monthly_new.values.tolist(),
                'marker': {
                    'color': 'rgb(54, 162, 235)',
                    'opacity': 0.8
                },
                'name': 'New Families',
                'hovertemplate': 'Month: %{x}<br>New Families: %{y}<extra></extra>'
            }],
            'layout': {
                'title': 'New Malware Families by Month',
                'xaxis': {
                    'title': 'Month',
                    'tickangle': 45,
                    'tickmode': 'array',
                    'showgrid': True
                },
                'yaxis': {
                    'title': 'Number of New Families',
                    'showgrid': True
                },
                'bargap': 0.2,
                'hovermode': 'closest'
            }
        }

        # Create visualization
        self.save_plot('new_families_timeline')
        return data

    def get_trend_data(self):
        """Analyze malware trends"""
        df_indexed = self.df.set_index('first_seen_utc')
        monthly = df_indexed.resample('ME')['signature'].value_counts()
        top_families = self.df['signature'].value_counts().head(10).index
        
        # Format data for Plotly
        traces = []
        for family in top_families:
            family_data = monthly[monthly.index.get_level_values(1) == family]
            traces.append({
                'type': 'scatter',
                'mode': 'lines+markers',
                'name': family,
                'x': family_data.index.get_level_values(0).strftime('%Y-%m').tolist(),
                'y': family_data.values.tolist(),
                'hovertemplate': 'Date: %{x}<br>Samples: %{y}<br>Family: ' + family + '<extra></extra>'
            })
        
        data = {
            'data': traces,
            'layout': {
                'title': 'Malware Family Trends',
                'xaxis': {'title': 'Date', 'tickangle': 45},
                'yaxis': {'title': 'Number of Samples'},
                'showlegend': True,
                'hovermode': 'closest'
            }
        }

        self.save_plot('malware_trends')
        return data

    def get_signature_stats(self):
        sig_counts = self.df['signature'].value_counts()
        sig_counts = sig_counts[sig_counts.index != 'N/A'].head(15)
        
        data = {
            'data': [{
                'type': 'bar',
                'x': sig_counts.index.tolist(),
                'y': sig_counts.values.tolist(),
                'marker': {'color': 'rgb(54, 162, 235)'},
                'hovertemplate': '%{x}<br>Samples: %{y}<extra></extra>'
            }],
            'layout': {
                'title': 'Malware Family Distribution',
                'xaxis': {'title': 'Malware Family', 'tickangle': 45},
                'yaxis': {'title': 'Number of Samples'},
                'margin': {'b': 100},
                'hovermode': 'closest'
            }
        }

        self.save_plot('signature_distribution')
        return data

    def get_temporal_patterns(self):
        patterns = pd.crosstab(
            self.df['first_seen_utc'].dt.month,
            self.df['first_seen_utc'].dt.day_name()
        )
        
        data = {
            'data': [{
                'type': 'heatmap',
                'z': patterns.values.tolist(),
                'x': patterns.columns.tolist(),
                'y': patterns.index.tolist(),
                'colorscale': 'YlOrRd',
                'hovertemplate': 'Day: %{x}<br>Month: %{y}<br>Count: %{z}<extra></extra>'
            }],
            'layout': {
                'title': 'Activity by Day and Month',
                'xaxis': {'title': 'Day of Week'},
                'yaxis': {'title': 'Month'},
                'margin': {'b': 100},
                'hovermode': 'closest'
            }
        }

        self.save_plot('temporal_heatmap')
        return data

    def get_emerging_threats(self, days=30):
        recent_cutoff = self.df['first_seen_utc'].max() - pd.Timedelta(days=days)
        recent_df = self.df[self.df['first_seen_utc'] > recent_cutoff]
        
        recent_counts = recent_df['signature'].value_counts()
        total_counts = self.df['signature'].value_counts()
        
        growth_rates = {}
        for sig in recent_counts.index:
            growth_rates[sig] = {
                'recent_count': int(recent_counts[sig]),
                'total_count': int(total_counts[sig]),
                'growth_rate': float((recent_counts[sig] / total_counts[sig]) * 100)
            }
        
        return {
            'title': f'Emerging Threats (Last {days} days)',
            'threats': growth_rates
        }

    def get_hourly_activity(self):
        hourly = self.df['first_seen_utc'].dt.hour.value_counts().sort_index()
        
        data = {
            'data': [{
                'type': 'bar',
                'x': hourly.index.tolist(),
                'y': hourly.values.tolist(),
                'marker': {'color': 'rgb(54, 162, 235)'},
                'hovertemplate': 'Hour: %{x}:00<br>Samples: %{y}<extra></extra>'
            }],
            'layout': {
                'title': 'Hourly Activity Distribution',
                'xaxis': {'title': 'Hour of Day'},
                'yaxis': {'title': 'Number of Samples'},
                'bargap': 0.1,
                'hovermode': 'closest'
            }
        }

        self.save_plot('hourly_activity')
        return data

    def get_monthly_activity(self):
        """Analyze monthly activity patterns"""
        # Create pivot table with better date handling
        df_indexed = self.df.copy()
        df_indexed['year'] = df_indexed['first_seen_utc'].dt.year
        df_indexed['month'] = df_indexed['first_seen_utc'].dt.month
        
        # Create monthly counts
        monthly = pd.pivot_table(
            df_indexed,
            values='md5_hash',
            index='year',
            columns='month',
            aggfunc='count',
            fill_value=0
        ).astype(float)
        
        # Ensure we have data
        if monthly.empty:
            print("Warning: No monthly activity data available")
            return {
                'title': 'Monthly Activity Heatmap',
                'data': {},
                'years': [],
                'months': []
            }
        
        # Prepare data for visualization
        data = {
            'data': [{
                'type': 'heatmap',
                'z': monthly.values.tolist(),
                'x': [calendar.month_abbr[m] for m in monthly.columns],
                'y': monthly.index.tolist(),
                'colorscale': 'YlOrRd',
                'hovertemplate': 'Month: %{x}<br>Year: %{y}<br>Samples: %{z}<extra></extra>'
            }],
            'layout': {
                'title': 'Monthly Activity Heatmap',
                'xaxis': {'title': 'Month'},
                'yaxis': {'title': 'Year'},
                'margin': {'b': 100},
                'hovermode': 'closest'
            }
        }

        self.save_plot('seasonal_heatmap')
        return data

    def get_signature_evolution(self):
        """Track signature evolution over time"""
        # Set datetime index
        df_indexed = self.df.set_index('first_seen_utc')
        monthly_totals = df_indexed.resample('ME').size()
        top_sigs = self.df['signature'].value_counts()[self.df['signature'] != 'N/A'].head(8).index
        
        traces = []
        for sig in top_sigs:
            sig_monthly = (df_indexed[df_indexed['signature'] == sig]
                         .resample('ME').size())
            traces.append({
                'type': 'scatter',
                'mode': 'lines',
                'name': sig,
                'x': sig_monthly.index.strftime('%Y-%m').tolist(),
                'y': ((sig_monthly / monthly_totals) * 100).fillna(0).tolist(),
                'stackgroup': 'one',
                'hovertemplate': 'Date: %{x}<br>Percentage: %{y:.1f}%<br>Family: ' + sig + '<extra></extra>'
            })
        
        data = {
            'data': traces,
            'layout': {
                'title': 'Malware Family Evolution',
                'xaxis': {'title': 'Date', 'tickangle': 45},
                'yaxis': {'title': 'Percentage', 'range': [0, 100]},
                'showlegend': True,
                'hovermode': 'closest'
            }
        }

        self.save_plot('signature_evolution')
        return data

    def get_summary_stats(self):
        return {
            'total_samples': len(self.df),
            'unique_families': self.df['signature'].nunique(),
            'date_range': {
                'start': self.df['first_seen_utc'].min().strftime('%Y-%m-%d'),
                'end': self.df['first_seen_utc'].max().strftime('%Y-%m-%d')
            },
            'top_families': self.df['signature'].value_counts().head(10).to_dict()
        }

if __name__ == "__main__":
    db_path = Path("malware_hashes.db")
    if not db_path.exists():
        print(f"Error: Database {db_path} not found")
        exit(1)
    
    analyzer = MalwareAnalyzer(db_path)
    analyzer.export_data()
